curve_server(3)
===============

NAME
----
curve_server - Secure server socket

SYNOPSIS
--------
----
//  Create a new server instance, providing its permanent keypair
CZMQ_EXPORT curve_server_t *
    curve_server_new (curve_keypair_t **keypair_p);

//  Destructor
CZMQ_EXPORT void
    curve_server_destroy (curve_server_t **self_p);

//  Set metadata property, will be sent to clients at connection
CZMQ_EXPORT void
    curve_server_set_metadata (curve_server_t *self, char *name, char *format, ...);

//  Enable verbose tracing of commands and activity
CZMQ_EXPORT void
    curve_server_set_verbose (curve_server_t *self, bool verbose);

//  Bind server socket to local endpoint
CZMQ_EXPORT void
    curve_server_bind (curve_server_t *self, char *endpoint);

//  Unbind server socket from local endpoint, idempotent
CZMQ_EXPORT void
    curve_server_unbind (curve_server_t *self, char *endpoint);

//  Wait for message from server
CZMQ_EXPORT zmsg_t *
    curve_server_recv (curve_server_t *self);

//  Send message to server, takes ownership of message
CZMQ_EXPORT int
    curve_server_send (curve_server_t *self, zmsg_t **msg_p);

//  Get socket handle, for polling
CZMQ_EXPORT void *
    curve_server_handle (curve_server_t *self);

//  Self test of this class
void
    curve_server_test (bool verbose);
----

DESCRIPTION
-----------

Implements a secure server socket, doing I/O in the background. This is
a high-level class intended for applications. It wraps the curve_codec
class, and runs it across a ROUTER socket to connect to a curve_server
socket at the other end.


EXAMPLE
-------
.From curve_server_test method
----
    curve_keystore_t *keystore = curve_keystore_new ();
    int rc = curve_keystore_load (keystore, "test_keystore");
    assert (rc == 0);

    curve_keypair_t *server_keypair = curve_keystore_get (keystore, "server");
    curve_server_t *server = curve_server_new (&server_keypair);
    curve_server_set_metadata (server, "Server", "CURVEZMQ/curve_server");
    curve_server_set_verbose (server, verbose);
    curve_server_bind (server, "tcp://*:9000");
    curve_keystore_destroy (&keystore);

    while (live_clients > 0) {
        zmsg_t *msg = curve_server_recv (server);
        if (memcmp (zframe_data (zmsg_last (msg)), "END", 3) == 0)
            live_clients--;
        curve_server_send (server, &msg);
    }
    curve_server_destroy (&server);
    //  No other way to ensure client threads have exited before we do
    zclock_sleep (100);
----

SEE ALSO
--------
linkczmq:czmq[7]
